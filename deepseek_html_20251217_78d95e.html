<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电子秤数据稳定化模拟器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            margin-bottom: 10px;
            color: #61dafb;
        }

        .controls {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        label {
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        .value-display {
            font-size: 0.8rem;
            color: #61dafb;
            margin-left: 5px;
        }
        
        select {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 0.9rem;
            width: 200px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 400px;
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }
        
        .info-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            max-width: 800px;
            font-size: 0.85rem;
            color: #ccc;
            border-left: 4px solid #61dafb;
        }
        
        .metric-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 10px;
            width: 100%;
            max-width: 800px;
            font-size: 0.8rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .metric {
            text-align: center;
        }
        
        .metric-value {
            font-size: 1rem;
            font-weight: bold;
            color: #61dafb;
        }
        
        .metric-label {
            font-size: 0.7rem;
            color: #aaa;
        }
        
        .stability-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        .stable {
            background-color: #00ff00;
        }
        
        .unstable {
            background-color: #ff4444;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>

    <h2>电子秤数据稳定化模拟器</h2>

    <div class="controls">
        <div class="control-group">
            <label>滤波器类型 <span id="val-algo" class="value-display">DC补偿器</span></label>
            <select id="filterAlgorithm">
                <option value="dcblocker">DC补偿器 (DC Blocker)</option>
                <option value="medianavg">移动中值+平均组合</option>
                <option value="kalman">卡尔曼滤波器</option>
                <option value="wavelet">小波去噪</option>
                <option value="adaptive">自适应DC补偿</option>
                <option value="combined">组合滤波器 (推荐)</option>
            </select>
        </div>
        <div class="control-group">
            <label>漂移幅度 (Drift Amp) <span id="val-drift" class="value-display">80</span></label>
            <input type="range" id="driftAmp" min="0" max="150" value="80">
        </div>
        <div class="control-group">
            <label>漂移速度 (Drift Freq) <span id="val-speed" class="value-display">10</span></label>
            <input type="range" id="driftSpeed" min="1" max="50" value="10">
        </div>
        <div class="control-group">
            <label>高频噪声 (HF Noise) <span id="val-noise" class="value-display">5</span></label>
            <input type="range" id="noiseAmp" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>滤波强度 <span id="val-intensity" class="value-display">0.995</span></label>
            <input type="range" id="filterIntensity" min="800" max="999" value="995">
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="scopeCanvas"></canvas>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="color-box" style="background-color: #ff4444;"></div>
            <span>原始数据 (Raw)</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #00ff00;"></div>
            <span>滤波后数据 (Filtered)</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #ffff00;"></div>
            <span>预测实际值 (Predicted)</span>
        </div>
    </div>
    
    <div class="metric-panel">
        <div class="metric">
            <div class="metric-value" id="metric-current">0.0</div>
            <div class="metric-label">当前读数</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-stability">0.0</div>
            <div class="metric-label">稳定性 <span id="stability-indicator" class="stability-indicator unstable"></span></div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-response">0.0</div>
            <div class="metric-label">响应时间 (ms)</div>
        </div>
    </div>
    
    <div class="info-panel" id="algorithmInfo">
        <strong>DC补偿器 (DC Blocker)</strong>: 使用高通滤波器去除低频漂移，输出 = 原始 - 基线
    </div>

    <script>
        // --- 1. 基础设置 ---
        const canvas = document.getElementById('scopeCanvas');
        const ctx = canvas.getContext('2d');
        const algorithmInfo = document.getElementById('algorithmInfo');
        
        // 适应屏幕分辨率
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 参数控制
        const params = {
            driftAmp: 80,
            driftSpeed: 0.002,
            noiseAmp: 5,
            intensity: 0.995,
            algorithm: 'dcblocker'
        };

        // UI 绑定
        document.getElementById('driftAmp').oninput = function() { 
            params.driftAmp = parseInt(this.value); 
            document.getElementById('val-drift').innerText = this.value;
        };
        document.getElementById('driftSpeed').oninput = function() { 
            let val = parseInt(this.value);
            params.driftSpeed = val * 0.0002; 
            document.getElementById('val-speed').innerText = val;
        };
        document.getElementById('noiseAmp').oninput = function() { 
            params.noiseAmp = parseInt(this.value); 
            document.getElementById('val-noise').innerText = this.value;
        };
        document.getElementById('filterIntensity').oninput = function() { 
            let val = parseInt(this.value);
            params.intensity = val / 1000; 
            document.getElementById('val-intensity').innerText = params.intensity.toFixed(3);
        };
        document.getElementById('filterAlgorithm').oninput = function() { 
            params.algorithm = this.value;
            document.getElementById('val-algo').innerText = this.options[this.selectedIndex].text;
            updateAlgorithmInfo();
            resetFilters();
        };

        // 更新算法信息面板
        function updateAlgorithmInfo() {
            const infoMap = {
                'dcblocker': '<strong>DC补偿器 (DC Blocker)</strong>: 使用高通滤波器去除低频漂移，输出 = 原始 - 基线',
                'medianavg': '<strong>移动中值+平均组合</strong>: 中值滤波去除脉冲噪声，移动平均平滑信号',
                'kalman': '<strong>卡尔曼滤波器</strong>: 最优估计器，自适应调整增益',
                'wavelet': '<strong>小波去噪</strong>: 多尺度分析分离信号与噪声',
                'adaptive': '<strong>自适应DC补偿</strong>: 动态调整时间常数，区分信号突变和基线漂移',
                'combined': '<strong>组合滤波器</strong>: 先中值滤波去除脉冲，再自适应DC补偿去漂移，最后移动平均平滑'
            };
            algorithmInfo.innerHTML = infoMap[params.algorithm];
        }

        // --- 2. 信号生成工具 ---
        const perm = [];
        let gradP = [];
        
        function seedNoise() {
            gradP = [];
            for(let i=0; i<256; i++) {
                gradP.push(Math.random() * 2 - 1);
            }
        }
        seedNoise();

        function getSmoothNoise(t) {
            const index = Math.floor(t) % 256;
            const nextIndex = (index + 1) % 256;
            const factor = t - Math.floor(t);
            const smoothFactor = (1 - Math.cos(factor * Math.PI)) / 2;
            return gradP[index] * (1 - smoothFactor) + gradP[nextIndex] * smoothFactor;
        }

        // --- 3. 滤波器实现 ---
        
        // 1) DC Blocker 滤波器
        let dcPrevX = 0;
        let dcPrevY = 0;
        
        function dcBlocker(input, alpha) {
            let output = input - dcPrevX + alpha * dcPrevY;
            dcPrevX = input;
            dcPrevY = output;
            return output;
        }
        
        // 2) 移动中值+移动平均组合滤波器
        const medianWindow = 5;
        const avgWindow = 10;
        let medianBuffer = new Array(medianWindow).fill(0);
        let avgBuffer = new Array(avgWindow).fill(0);
        let medianIdx = 0;
        let avgIdx = 0;
        
        function medianAvgFilter(input) {
            // 中值滤波
            medianBuffer[medianIdx] = input;
            medianIdx = (medianIdx + 1) % medianWindow;
            
            const sorted = [...medianBuffer].sort((a,b) => a-b);
            const median = sorted[Math.floor(medianWindow/2)];
            
            // 移动平均
            avgBuffer[avgIdx] = median;
            avgIdx = (avgIdx + 1) % avgWindow;
            
            const sum = avgBuffer.reduce((a,b) => a+b);
            return sum / avgWindow;
        }
        
        // 3) 卡尔曼滤波器
        class KalmanFilter {
            constructor(Q = 0.01, R = 1) {
                this.Q = Q; // 过程噪声
                this.R = R; // 测量噪声
                this.P = 1; // 估计误差协方差
                this.X = 0; // 估计值
            }
            
            update(measurement) {
                // 预测
                const X_pred = this.X;
                const P_pred = this.P + this.Q;
                
                // 更新
                const K = P_pred / (P_pred + this.R); // 卡尔曼增益
                this.X = X_pred + K * (measurement - X_pred);
                this.P = (1 - K) * P_pred;
                
                return this.X;
            }
            
            reset() {
                this.P = 1;
                this.X = 0;
            }
        }
        const kalmanFilter = new KalmanFilter();
        
        // 4) 小波去噪滤波器
        const waveletWindow = 32;
        let waveletBuffer = new Array(waveletWindow).fill(0);
        let waveletIdx = 0;
        
        function waveletDenoise(input) {
            waveletBuffer[waveletIdx] = input;
            waveletIdx = (waveletIdx + 1) % waveletWindow;
            
            // 计算移动平均作为基线
            const baseline = waveletBuffer.reduce((a,b) => a+b) / waveletWindow;
            
            // 对细节系数进行阈值处理
            const detail = input - baseline;
            const threshold = params.noiseAmp * 0.7;
            
            let filteredDetail;
            if(Math.abs(detail) > threshold) {
                // 软阈值
                filteredDetail = Math.sign(detail) * (Math.abs(detail) - threshold);
            } else {
                filteredDetail = 0;
            }
            
            return {
                filtered: baseline + filteredDetail,
                baseline: baseline
            };
        }
        
        // 5) 自适应DC补偿滤波器
        class AdaptiveDCBlocker {
            constructor(slowAlpha = 0.995, fastAlpha = 0.9) {
                this.slowAlpha = slowAlpha;
                this.fastAlpha = fastAlpha;
                this.dcSlow = 0;
                this.dcFast = 0;
                this.output = 0;
            }
            
            process(input) {
                // 快速通道：跟踪信号突变
                this.dcFast = this.fastAlpha * this.dcFast + (1 - this.fastAlpha) * input;
                
                // 慢速通道：跟踪基线漂移
                this.dcSlow = this.slowAlpha * this.dcSlow + (1 - this.slowAlpha) * input;
                
                // 检测信号突变
                const diff = Math.abs(this.dcFast - this.dcSlow);
                const threshold = params.noiseAmp * 3;
                const isSignalChange = diff > threshold;
                
                // 选择跟踪源
                const dcEstimate = isSignalChange ? this.dcSlow : (this.dcFast + this.dcSlow) / 2;
                
                this.output = input - dcEstimate;
                return {filtered: this.output, baseline: dcEstimate};
            }
            
            reset() {
                this.dcSlow = 0;
                this.dcFast = 0;
                this.output = 0;
            }
        }
        const adaptiveFilter = new AdaptiveDCBlocker(0.995, 0.9);
        
        // 6) 组合滤波器 (中值 + 自适应DC + 移动平均)
        let combinedMedianBuffer = new Array(5).fill(0);
        let combinedMedianIdx = 0;
        const combinedAdaptiveFilter = new AdaptiveDCBlocker(0.995, 0.95);
        let combinedAvgBuffer = new Array(20).fill(0);
        let combinedAvgIdx = 0;
        
        function combinedFilter(input) {
            // 第一步：中值滤波去除脉冲
            combinedMedianBuffer[combinedMedianIdx] = input;
            combinedMedianIdx = (combinedMedianIdx + 1) % 5;
            const sorted = [...combinedMedianBuffer].sort((a,b) => a-b);
            const median = sorted[Math.floor(5/2)];
            
            // 第二步：自适应DC补偿去漂移
            const adaptiveResult = combinedAdaptiveFilter.process(median);
            const dcRemoved = adaptiveResult.filtered;
            
            // 第三步：移动平均平滑
            combinedAvgBuffer[combinedAvgIdx] = dcRemoved;
            combinedAvgIdx = (combinedAvgIdx + 1) % 20;
            const sum = combinedAvgBuffer.reduce((a,b) => a+b);
            const finalValue = sum / 20;
            
            return {
                filtered: dcRemoved,
                predicted: finalValue,
                baseline: adaptiveResult.baseline
            };
        }
        
        // 7) 稳定性滤波器 - 用于从滤波后数据中得到稳定的预测值
        class StabilityFilter {
            constructor(windowSize = 50, stabilityThreshold = 0.5) {
                this.windowSize = windowSize;
                this.stabilityThreshold = stabilityThreshold;
                this.buffer = new Array(windowSize).fill(0);
                this.idx = 0;
                this.lastStableValue = 0;
                this.stableCount = 0;
            }
            
            update(filteredValue) {
                // 添加到缓冲区
                this.buffer[this.idx] = filteredValue;
                this.idx = (this.idx + 1) % this.windowSize;
                
                // 计算窗口内数据的方差
                const mean = this.buffer.reduce((a,b) => a+b) / this.windowSize;
                const variance = this.buffer.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.windowSize;
                
                // 如果方差很小，说明数据稳定
                if (variance < this.stabilityThreshold) {
                    this.stableCount++;
                    // 连续稳定多次后，更新稳定值
                    if (this.stableCount > 10) {
                        this.lastStableValue = mean;
                    }
                } else {
                    this.stableCount = 0;
                }
                
                return {
                    predicted: this.lastStableValue,
                    variance: variance,
                    isStable: variance < this.stabilityThreshold
                };
            }
            
            reset() {
                this.buffer.fill(0);
                this.lastStableValue = 0;
                this.stableCount = 0;
            }
        }
        
        const stabilityFilter = new StabilityFilter(50, 0.5);

        // 重置所有滤波器状态
        function resetFilters() {
            dcPrevX = 0;
            dcPrevY = 0;
            medianBuffer.fill(0);
            avgBuffer.fill(0);
            waveletBuffer.fill(0);
            kalmanFilter.reset();
            adaptiveFilter.reset();
            stabilityFilter.reset();
            combinedMedianBuffer.fill(0);
            combinedAvgBuffer.fill(0);
            combinedAdaptiveFilter.reset();
        }

        // --- 4. 性能指标计算 ---
        let lastSignalChangeTime = 0;
        let responseStartValue = 0;
        
        function updateMetrics(raw, filtered, predicted, isStable) {
            // 1. 当前读数
            document.getElementById('metric-current').innerText = predicted.toFixed(1);
            
            // 2. 稳定性指标
            const stabilityValue = isStable ? 0.0 : 99.9;
            document.getElementById('metric-stability').innerText = stabilityValue.toFixed(1);
            
            // 更新稳定性指示灯
            const indicator = document.getElementById('stability-indicator');
            indicator.className = 'stability-indicator ' + (isStable ? 'stable' : 'unstable');
            
            // 3. 响应时间检测
            if (Math.abs(filtered - responseStartValue) > 10) {
                lastSignalChangeTime = performance.now();
                responseStartValue = filtered;
            }
            const responseTime = performance.now() - lastSignalChangeTime;
            document.getElementById('metric-response').innerText = responseTime.toFixed(0);
        }

        // --- 5. 主循环与绘图 ---
        
        // 数据缓冲区
        const maxPoints = 800;
        const dataRaw = new Array(maxPoints).fill(0);
        const dataFiltered = new Array(maxPoints).fill(0);
        const dataPredicted = new Array(maxPoints).fill(0);
        
        let time = 0;
        let signalBase = 0; // 模拟电子秤的真实重量值
        let signalTimer = 0;

        function loop() {
            // 1. 生成模拟数据
            time += 1;
            
            // A. 真实漂移（电子秤的漂移特性）
            let trueDrift = getSmoothNoise(time * params.driftSpeed) * params.driftAmp;
            
            // B. 高频噪声
            let hfNoise = (Math.random() - 0.5) * params.noiseAmp * 2;

            // C. 模拟重量变化（每200个采样点变化一次）
            signalTimer++;
            if (signalTimer > 200) {
                // 随机变化重量：0, 50, 100, 150 之间切换
                const possibleValues = [0, 50, 100, 150];
                const currentIndex = possibleValues.indexOf(signalBase);
                const nextIndex = (currentIndex + 1) % possibleValues.length;
                signalBase = possibleValues[nextIndex];
                signalTimer = 0;
            }

            // 合成原始数据 = 真实重量 + 漂移 + 噪声
            let rawSample = signalBase + trueDrift + hfNoise;

            // 2. 根据选择的算法进行滤波处理
            let filteredSample = 0;
            let predictedValue = 0;
            let isStable = false;
            
            switch(params.algorithm) {
                case 'dcblocker':
                    filteredSample = dcBlocker(rawSample, params.intensity);
                    // 使用稳定性滤波器得到预测值
                    const dcResult = stabilityFilter.update(filteredSample);
                    predictedValue = dcResult.predicted;
                    isStable = dcResult.isStable;
                    break;
                    
                case 'medianavg':
                    filteredSample = medianAvgFilter(rawSample);
                    const maResult = stabilityFilter.update(filteredSample);
                    predictedValue = maResult.predicted;
                    isStable = maResult.isStable;
                    break;
                    
                case 'kalman':
                    filteredSample = kalmanFilter.update(rawSample);
                    const kfResult = stabilityFilter.update(filteredSample);
                    predictedValue = kfResult.predicted;
                    isStable = kfResult.isStable;
                    break;
                    
                case 'wavelet':
                    const waveletResult = waveletDenoise(rawSample);
                    filteredSample = waveletResult.filtered;
                    const wvResult = stabilityFilter.update(filteredSample);
                    predictedValue = wvResult.predicted;
                    isStable = wvResult.isStable;
                    break;
                    
                case 'adaptive':
                    const adaptiveResult = adaptiveFilter.process(rawSample);
                    filteredSample = adaptiveResult.filtered;
                    const adResult = stabilityFilter.update(filteredSample);
                    predictedValue = adResult.predicted;
                    isStable = adResult.isStable;
                    break;
                    
                case 'combined':
                    const combinedResult = combinedFilter(rawSample);
                    filteredSample = combinedResult.filtered;
                    predictedValue = combinedResult.predicted;
                    // 组合滤波器自带稳定性，使用较小的阈值判断
                    const combResult = stabilityFilter.update(filteredSample);
                    isStable = combResult.variance < 0.2;
                    break;
                    
                default:
                    filteredSample = dcBlocker(rawSample, params.intensity);
                    const defResult = stabilityFilter.update(filteredSample);
                    predictedValue = defResult.predicted;
                    isStable = defResult.isStable;
            }

            // 3. 更新性能指标
            updateMetrics(rawSample, filteredSample, predictedValue, isStable);

            // 4. 更新缓冲区
            dataRaw.shift(); dataRaw.push(rawSample);
            dataFiltered.shift(); dataFiltered.push(filteredSample);
            dataPredicted.shift(); dataPredicted.push(predictedValue);

            // 5. 绘图
            draw();

            requestAnimationFrame(loop);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerY = canvas.height / 2;
            const scaleX = canvas.width / maxPoints;
            
            // 计算数据范围用于自动缩放
            const allData = [...dataRaw, ...dataFiltered, ...dataPredicted];
            const maxVal = Math.max(...allData);
            const minVal = Math.min(...allData);
            const dataRange = Math.max(Math.abs(maxVal), Math.abs(minVal)) * 1.5;
            const scaleY = canvas.height / (dataRange * 2);

            // 绘制网格
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let y = 0; y <= canvas.height; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            for(let x = 0; x <= canvas.width; x += 100) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();
            
            // 绘制零线
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();

            // 绘制预测实际值 (黄色，粗线)
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataPredicted[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 绘制原始数据 (红色)
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataRaw[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 绘制滤波后数据 (绿色)
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataFiltered[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制算法名称
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = 'bold 16px Arial';
            const algoName = document.getElementById('filterAlgorithm').options[document.getElementById('filterAlgorithm').selectedIndex].text;
            ctx.fillText(`当前算法: ${algoName}`, 10, 25);
            
            // 绘制当前读数
            ctx.font = '14px Arial';
            ctx.fillText(`当前读数: ${document.getElementById('metric-current').innerText}`, 10, 50);
            
            // 绘制稳定性状态
            const isStable = document.getElementById('stability-indicator').classList.contains('stable');
            ctx.fillStyle = isStable ? '#00ff00' : '#ff4444';
            ctx.fillText(`状态: ${isStable ? '稳定' : '不稳定'}`, 10, 75);
        }

        // 初始化算法信息
        updateAlgorithmInfo();
        
        // 启动
        loop();

    </script>
</body>
</html>