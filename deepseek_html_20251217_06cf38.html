<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电子秤称重传感器模拟器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            margin-bottom: 10px;
            color: #61dafb;
        }

        .controls {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        label {
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        .value-display {
            font-size: 0.8rem;
            color: #61dafb;
            margin-left: 5px;
        }
        
        select {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 0.9rem;
            width: 200px;
        }
        
        .weight-controls {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            width: 100%;
            max-width: 800px;
        }
        
        .weight-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }
        
        .weight-btn:hover {
            background-color: #555;
        }
        
        .weight-btn.active {
            background-color: #61dafb;
            color: black;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 400px;
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }
        
        .info-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            max-width: 800px;
            font-size: 0.85rem;
            color: #ccc;
            border-left: 4px solid #61dafb;
        }
        
        .metric-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 10px;
            width: 100%;
            max-width: 800px;
            font-size: 0.8rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .metric {
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #61dafb;
        }
        
        .metric-label {
            font-size: 0.7rem;
            color: #aaa;
        }
        
        .current-weight {
            background-color: #2d2d2d;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 1.5rem;
            color: #61dafb;
            font-weight: bold;
            text-align: center;
            width: 100%;
            max-width: 800px;
        }
    </style>
</head>
<body>

    <h2>电子秤称重传感器模拟器</h2>

    <div class="weight-controls">
        <button class="weight-btn active" id="weight-0">空秤 (0g)</button>
        <button class="weight-btn" id="weight-100">100g</button>
        <button class="weight-btn" id="weight-500">500g</button>
        <button class="weight-btn" id="weight-1000">1000g</button>
        <button class="weight-btn" id="weight-custom">自定义重量</button>
        <input type="number" id="custom-weight" min="0" max="5000" value="250" style="display: none; width: 80px;">
    </div>

    <div class="controls">
        <div class="control-group">
            <label>滤波器类型 <span id="val-algo" class="value-display">均值滤波</span></label>
            <select id="filterAlgorithm">
                <option value="mean">均值滤波</option>
                <option value="median">中值滤波</option>
                <option value="kalman">卡尔曼滤波</option>
                <option value="exponential">指数平滑</option>
                <option value="weighted">加权移动平均</option>
                <option value="adaptive">自适应滤波</option>
            </select>
        </div>
        <div class="control-group">
            <label>传感器噪声 <span id="val-noise" class="value-display">5</span></label>
            <input type="range" id="noiseAmp" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>温度漂移 <span id="val-drift" class="value-display">0.5</span></label>
            <input type="range" id="driftAmp" min="0" max="10" value="5">
        </div>
        <div class="control-group">
            <label>滤波强度 <span id="val-intensity" class="value-display">10</span></label>
            <input type="range" id="filterIntensity" min="1" max="50" value="10">
        </div>
    </div>

    <div class="current-weight">
        当前重量: <span id="weight-value">0</span> g
    </div>

    <div class="canvas-container">
        <canvas id="scopeCanvas"></canvas>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="color-box" style="background-color: #ff4444;"></div>
            <span>传感器原始数据</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #00ff00;"></div>
            <span>滤波后数据</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #ffff00;"></div>
            <span>预测实际重量 (目标)</span>
        </div>
    </div>
    
    <div class="metric-panel">
        <div class="metric">
            <div class="metric-value" id="metric-stability">0.0</div>
            <div class="metric-label">稳定性 (σ)</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-error">0.0 g</div>
            <div class="metric-label">误差</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-response">0.0 s</div>
            <div class="metric-label">响应时间</div>
        </div>
    </div>
    
    <div class="info-panel" id="algorithmInfo">
        <strong>均值滤波</strong>: 简单计算窗口内数据的平均值，对高斯噪声有良好的抑制效果，但响应速度较慢。
    </div>

    <script>
        // --- 1. 基础设置 ---
        const canvas = document.getElementById('scopeCanvas');
        const ctx = canvas.getContext('2d');
        const algorithmInfo = document.getElementById('algorithmInfo');
        const weightValueDisplay = document.getElementById('weight-value');
        
        // 适应屏幕分辨率
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 电子秤参数
        const params = {
            targetWeight: 0,      // 目标重量 (g)
            noiseAmp: 5,          // 传感器噪声 (高斯噪声幅度)
            driftAmp: 0.5,        // 温度漂移幅度 (g/分钟)
            intensity: 10,        // 滤波强度/窗口大小
            algorithm: 'mean'     // 滤波算法
        };

        // 重量按钮控制
        document.querySelectorAll('.weight-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // 移除所有按钮的active类
                document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
                // 给当前按钮添加active类
                this.classList.add('active');
                
                if(this.id === 'weight-custom') {
                    document.getElementById('custom-weight').style.display = 'inline-block';
                    const customWeight = parseInt(document.getElementById('custom-weight').value);
                    if(!isNaN(customWeight) && customWeight >= 0) {
                        changeWeight(customWeight);
                    }
                } else {
                    document.getElementById('custom-weight').style.display = 'none';
                    const weight = parseInt(this.id.split('-')[1]);
                    changeWeight(weight);
                }
            });
        });
        
        document.getElementById('custom-weight').addEventListener('change', function() {
            if(document.getElementById('weight-custom').classList.contains('active')) {
                const weight = parseInt(this.value);
                if(!isNaN(weight) && weight >= 0) {
                    changeWeight(weight);
                }
            }
        });
        
        function changeWeight(newWeight) {
            params.targetWeight = newWeight;
            weightValueDisplay.textContent = newWeight;
            resetFilters(); // 重量改变时重置滤波器
            lastWeightChangeTime = Date.now();
        }

        // 参数控制绑定
        document.getElementById('noiseAmp').oninput = function() { 
            params.noiseAmp = parseInt(this.value); 
            document.getElementById('val-noise').innerText = this.value;
        };
        document.getElementById('driftAmp').oninput = function() { 
            params.driftAmp = parseFloat(this.value) / 10; 
            document.getElementById('val-drift').innerText = params.driftAmp.toFixed(1);
        };
        document.getElementById('filterIntensity').oninput = function() { 
            let val = parseInt(this.value);
            params.intensity = val; 
            document.getElementById('val-intensity').innerText = this.value;
            resetFilters(); // 强度改变时重置滤波器
        };
        document.getElementById('filterAlgorithm').oninput = function() { 
            params.algorithm = this.value;
            document.getElementById('val-algo').innerText = this.options[this.selectedIndex].text;
            updateAlgorithmInfo();
            resetFilters();
        };

        // 更新算法信息面板
        function updateAlgorithmInfo() {
            const infoMap = {
                'mean': '<strong>均值滤波</strong>: 简单计算窗口内数据的平均值，对高斯噪声有良好的抑制效果，但响应速度较慢。',
                'median': '<strong>中值滤波</strong>: 取窗口内数据的中值，对脉冲噪声（如震动）有很好的抑制效果。',
                'kalman': '<strong>卡尔曼滤波</strong>: 基于状态估计的最优滤波器，能根据噪声特性动态调整滤波强度。',
                'exponential': '<strong>指数平滑</strong>: 对近期数据赋予更高权重，响应速度快，但对噪声抑制较弱。',
                'weighted': '<strong>加权移动平均</strong>: 对窗口内数据赋予不同权重（近期权重高），平衡响应速度和稳定性。',
                'adaptive': '<strong>自适应滤波</strong>: 根据信号变化率动态调整滤波强度，在稳定时强滤波，变化时快速响应。'
            };
            algorithmInfo.innerHTML = infoMap[params.algorithm];
        }

        // --- 2. 电子秤信号生成 ---
        let temperatureDrift = 0;
        let driftDirection = 1;
        let lastDriftChange = 0;
        
        function generateScaleSignal() {
            // 1. 基础重量信号
            let baseSignal = params.targetWeight;
            
            // 2. 传感器噪声 (高斯分布)
            let noise = 0;
            for(let i = 0; i < 6; i++) {
                noise += (Math.random() - 0.5);
            }
            noise = noise * params.noiseAmp / 3;
            
            // 3. 温度漂移 (缓慢变化)
            const now = Date.now();
            if(now - lastDriftChange > 10000) { // 每10秒可能改变漂移方向
                if(Math.random() > 0.7) {
                    driftDirection *= -1;
                }
                lastDriftChange = now;
            }
            
            // 漂移速率: params.driftAmp g/分钟 = params.driftAmp/60000 g/毫秒
            temperatureDrift += driftDirection * params.driftAmp / 60000;
            
            // 4. 随机干扰 (模拟震动、空气流动等)
            let interference = 0;
            if(Math.random() > 0.95) { // 5%概率出现干扰
                interference = (Math.random() - 0.5) * params.noiseAmp * 3;
            }
            
            return baseSignal + noise + temperatureDrift + interference;
        }

        // --- 3. 滤波器实现 ---
        
        // 1) 均值滤波器
        let meanBuffer = [];
        
        function meanFilter(input) {
            meanBuffer.push(input);
            if(meanBuffer.length > params.intensity) {
                meanBuffer.shift();
            }
            
            const sum = meanBuffer.reduce((a, b) => a + b, 0);
            return sum / meanBuffer.length;
        }
        
        // 2) 中值滤波器
        let medianBuffer = [];
        
        function medianFilter(input) {
            medianBuffer.push(input);
            if(medianBuffer.length > params.intensity) {
                medianBuffer.shift();
            }
            
            const sorted = [...medianBuffer].sort((a, b) => a - b);
            return sorted[Math.floor(sorted.length / 2)];
        }
        
        // 3) 卡尔曼滤波器
        class KalmanFilter {
            constructor(Q = 0.1, R = 1) {
                this.Q = Q; // 过程噪声
                this.R = R; // 测量噪声
                this.P = 1; // 估计误差协方差
                this.X = 0; // 估计值
            }
            
            update(measurement) {
                // 预测
                const X_pred = this.X;
                const P_pred = this.P + this.Q;
                
                // 更新
                const K = P_pred / (P_pred + this.R); // 卡尔曼增益
                this.X = X_pred + K * (measurement - X_pred);
                this.P = (1 - K) * P_pred;
                
                return this.X;
            }
            
            reset() {
                this.P = 1;
                this.X = 0;
            }
        }
        const kalmanFilter = new KalmanFilter(0.01, Math.pow(params.noiseAmp, 2));
        
        // 4) 指数平滑滤波器
        let exponentialState = 0;
        let isExponentialFirst = true;
        
        function exponentialFilter(input) {
            if(isExponentialFirst) {
                exponentialState = input;
                isExponentialFirst = false;
                return input;
            }
            
            // alpha = 1/intensity，强度越大，alpha越小，平滑效果越强
            const alpha = 1 / params.intensity;
            exponentialState = alpha * input + (1 - alpha) * exponentialState;
            return exponentialState;
        }
        
        // 5) 加权移动平均滤波器
        let weightedBuffer = [];
        
        function weightedFilter(input) {
            weightedBuffer.push(input);
            if(weightedBuffer.length > params.intensity) {
                weightedBuffer.shift();
            }
            
            let sum = 0;
            let weightSum = 0;
            for(let i = 0; i < weightedBuffer.length; i++) {
                // 权重: 近期数据权重高，线性递减
                const weight = (i + 1) / weightedBuffer.length;
                sum += weightedBuffer[i] * weight;
                weightSum += weight;
            }
            
            return sum / weightSum;
        }
        
        // 6) 自适应滤波器
        let adaptiveBuffer = [];
        let adaptiveLastOutput = 0;
        
        function adaptiveFilter(input) {
            adaptiveBuffer.push(input);
            if(adaptiveBuffer.length > params.intensity * 2) {
                adaptiveBuffer.shift();
            }
            
            // 计算信号变化率
            let variance = 0;
            if(adaptiveBuffer.length > 5) {
                const mean = adaptiveBuffer.reduce((a, b) => a + b) / adaptiveBuffer.length;
                variance = adaptiveBuffer.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / adaptiveBuffer.length;
            }
            
            // 根据变化率动态调整滤波强度
            const dynamicIntensity = Math.max(1, Math.min(params.intensity * 2, 
                params.intensity * 10 / (variance + 0.1)));
            
            // 使用动态窗口大小的均值滤波
            const windowSize = Math.min(Math.floor(dynamicIntensity), adaptiveBuffer.length);
            const recentData = adaptiveBuffer.slice(-windowSize);
            const sum = recentData.reduce((a, b) => a + b, 0);
            
            adaptiveLastOutput = sum / windowSize;
            return adaptiveLastOutput;
        }

        // 重置所有滤波器状态
        function resetFilters() {
            meanBuffer = [];
            medianBuffer = [];
            weightedBuffer = [];
            adaptiveBuffer = [];
            exponentialState = 0;
            isExponentialFirst = true;
            kalmanFilter.reset();
            kalmanFilter.R = Math.pow(params.noiseAmp, 2);
            temperatureDrift = 0;
            lastDriftChange = Date.now();
        }

        // --- 4. 性能指标计算 ---
        let stabilityBuffer = [];
        let lastWeightChangeTime = Date.now();
        let settlingStartValue = 0;
        let settlingStartTime = 0;
        let isSettling = false;
        
        function updateMetrics(filteredValue) {
            // 1. 稳定性计算 (标准差)
            stabilityBuffer.push(filteredValue);
            if(stabilityBuffer.length > 100) {
                stabilityBuffer.shift();
            }
            
            if(stabilityBuffer.length > 10) {
                const mean = stabilityBuffer.reduce((a, b) => a + b) / stabilityBuffer.length;
                const variance = stabilityBuffer.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / stabilityBuffer.length;
                const stdDev = Math.sqrt(variance);
                document.getElementById('metric-stability').innerText = stdDev.toFixed(2);
            }
            
            // 2. 误差计算 (与目标重量的偏差)
            const error = Math.abs(filteredValue - params.targetWeight);
            document.getElementById('metric-error').innerText = error.toFixed(1) + ' g';
            
            // 3. 响应时间计算 (达到稳定状态的时间)
            const now = Date.now();
            const timeSinceChange = (now - lastWeightChangeTime) / 1000;
            
            if(timeSinceChange < 2) {
                // 重量变化后2秒内，显示响应时间
                document.getElementById('metric-response').innerText = timeSinceChange.toFixed(1) + ' s';
                
                // 检测是否开始稳定
                if(!isSettling && timeSinceChange > 0.1) {
                    settlingStartValue = filteredValue;
                    settlingStartTime = now;
                    isSettling = true;
                }
                
                // 如果已经稳定（波动小于0.5g持续0.2秒）
                if(isSettling && Math.abs(filteredValue - settlingStartValue) < 0.5) {
                    if(now - settlingStartTime > 200) {
                        document.getElementById('metric-response').innerText = ((settlingStartTime - lastWeightChangeTime) / 1000).toFixed(1) + ' s';
                    }
                } else {
                    isSettling = false;
                }
            } else {
                document.getElementById('metric-response').innerText = '稳定';
            }
        }

        // --- 5. 主循环与绘图 ---
        
        // 数据缓冲区
        const maxPoints = 500;
        const dataRaw = new Array(maxPoints).fill(0);
        const dataFiltered = new Array(maxPoints).fill(0);
        const dataTarget = new Array(maxPoints).fill(0); // 目标重量线

        function loop() {
            // 1. 生成电子秤原始信号
            const rawSample = generateScaleSignal();
            
            // 2. 根据选择的算法进行滤波处理
            let filteredSample = 0;
            
            switch(params.algorithm) {
                case 'mean':
                    filteredSample = meanFilter(rawSample);
                    break;
                    
                case 'median':
                    filteredSample = medianFilter(rawSample);
                    break;
                    
                case 'kalman':
                    filteredSample = kalmanFilter.update(rawSample);
                    break;
                    
                case 'exponential':
                    filteredSample = exponentialFilter(rawSample);
                    break;
                    
                case 'weighted':
                    filteredSample = weightedFilter(rawSample);
                    break;
                    
                case 'adaptive':
                    filteredSample = adaptiveFilter(rawSample);
                    break;
                    
                default:
                    filteredSample = meanFilter(rawSample);
            }
            
            // 3. 更新性能指标
            updateMetrics(filteredSample);
            
            // 4. 更新缓冲区
            dataRaw.shift(); dataRaw.push(rawSample);
            dataFiltered.shift(); dataFiltered.push(filteredSample);
            dataTarget.shift(); dataTarget.push(params.targetWeight);

            // 5. 绘图
            draw();

            requestAnimationFrame(loop);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 计算数据范围用于自动缩放
            const allRawData = [...dataRaw];
            const maxRawVal = Math.max(...allRawData, params.targetWeight + 20);
            const minRawVal = Math.min(...allRawData, params.targetWeight - 20);
            const dataRange = maxRawVal - minRawVal;
            const padding = dataRange * 0.1;
            
            const scaleY = canvas.height / (dataRange + padding * 2);
            const zeroY = canvas.height - (0 - minRawVal + padding) * scaleY;
            
            const scaleX = canvas.width / maxPoints;
            
            // 绘制网格和参考线
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            // 水平网格线 (每10g一条)
            const gridStep = 10;
            const startGrid = Math.floor(minRawVal / gridStep) * gridStep;
            const endGrid = Math.ceil(maxRawVal / gridStep) * gridStep;
            
            for(let weight = startGrid; weight <= endGrid; weight += gridStep) {
                const y = zeroY - weight * scaleY;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                
                // 网格标签
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText(weight + 'g', 5, y - 2);
            }
            
            // 垂直网格线 (时间刻度)
            for(let x = 0; x <= canvas.width; x += 100) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            
            ctx.stroke();
            
            // 绘制目标重量线 (黄色，粗线)
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const targetY = zeroY - params.targetWeight * scaleY;
            ctx.moveTo(0, targetY);
            ctx.lineTo(canvas.width, targetY);
            ctx.stroke();
            
            // 绘制原始数据 (红色，细线)
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = zeroY - dataRaw[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制滤波后数据 (绿色，粗线)
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = zeroY - dataFiltered[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制算法名称和当前读数
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = 'bold 16px Arial';
            const algoName = document.getElementById('filterAlgorithm').options[document.getElementById('filterAlgorithm').selectedIndex].text;
            ctx.fillText(`算法: ${algoName}`, 10, 25);
            
            ctx.font = '14px Arial';
            const currentFiltered = dataFiltered[dataFiltered.length - 1];
            ctx.fillText(`当前读数: ${currentFiltered.toFixed(1)} g`, 10, 50);
            ctx.fillText(`目标重量: ${params.targetWeight} g`, 10, 70);
            
            // 绘制读数误差
            const error = currentFiltered - params.targetWeight;
            ctx.fillStyle = error > 1 ? '#ff4444' : (error < -1 ? '#ff4444' : '#00ff00');
            ctx.fillText(`误差: ${error.toFixed(1)} g`, 10, 90);
        }

        // 初始化算法信息
        updateAlgorithmInfo();
        
        // 启动
        loop();

    </script>
</body>
</html>