<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电子秤数据稳定化模拟器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            margin-bottom: 10px;
            color: #61dafb;
        }

        .controls {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        label {
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }
        
        input[type="number"] {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 0.9rem;
            width: 100px;
        }
        
        button {
            background-color: #61dafb;
            color: #1e1e1e;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #4fa3d1;
        }

        .value-display {
            font-size: 0.8rem;
            color: #61dafb;
            margin-left: 5px;
        }
        
        select {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 0.9rem;
            width: 200px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 400px;
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }
        
        .info-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            max-width: 800px;
            font-size: 0.85rem;
            color: #ccc;
            border-left: 4px solid #61dafb;
        }
        
        .metric-panel {
            background-color: #2d2d2d;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 10px;
            width: 100%;
            max-width: 800px;
            font-size: 0.8rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .metric {
            text-align: center;
        }
        
        .metric-value {
            font-size: 1rem;
            font-weight: bold;
            color: #61dafb;
        }
        
        .metric-label {
            font-size: 0.7rem;
            color: #aaa;
        }
        
        .stability-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        .stable {
            background-color: #00ff00;
        }
        
        .unstable {
            background-color: #ff4444;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .weight-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
    </style>
</head>
<body>

    <h2>电子秤数据稳定化模拟器</h2>

    <div class="controls">
        <div class="control-group">
            <label>滤波器类型 <span id="val-algo" class="value-display">组合滤波器</span></label>
            <select id="filterAlgorithm">
                <option value="combined">组合滤波器 (推荐)</option>
                <option value="adaptive">自适应DC补偿</option>
                <option value="kalman">卡尔曼滤波器</option>
                <option value="dcblocker">DC补偿器</option>
                <option value="medianavg">移动中值+平均</option>
                <option value="wavelet">小波去噪</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>砝码重量 <span id="val-weight" class="value-display">0</span> g</label>
            <div class="weight-controls">
                <input type="number" id="weightInput" min="0" max="500" value="0">
                <button id="applyWeight">应用重量</button>
            </div>
            <div style="margin-top: 5px;">
                <button id="weight0" style="padding: 4px 8px; font-size: 0.8rem;">0g</button>
                <button id="weight50" style="padding: 4px 8px; font-size: 0.8rem;">50g</button>
                <button id="weight100" style="padding: 4px 8px; font-size: 0.8rem;">100g</button>
                <button id="weight200" style="padding: 4px 8px; font-size: 0.8rem;">200g</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>漂移幅度 (Drift Amp) <span id="val-drift" class="value-display">80</span></label>
            <input type="range" id="driftAmp" min="0" max="150" value="80">
        </div>
        <div class="control-group">
            <label>漂移速度 (Drift Freq) <span id="val-speed" class="value-display">10</span></label>
            <input type="range" id="driftSpeed" min="1" max="50" value="10">
        </div>
        <div class="control-group">
            <label>高频噪声 (HF Noise) <span id="val-noise" class="value-display">5</span></label>
            <input type="range" id="noiseAmp" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>滤波强度 <span id="val-intensity" class="value-display">0.995</span></label>
            <input type="range" id="filterIntensity" min="800" max="999" value="995">
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="scopeCanvas"></canvas>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="color-box" style="background-color: #ff4444;"></div>
            <span>原始数据 (Raw ADC)</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #00ff00;"></div>
            <span>滤波后数据 (Filtered)</span>
        </div>
        <div class="legend-item">
            <div class="color-box" style="background-color: #ffff00;"></div>
            <span>稳定显示值 (Display)</span>
        </div>
    </div>
    
    <div class="metric-panel">
        <div class="metric">
            <div class="metric-value" id="metric-current">0.0</div>
            <div class="metric-label">当前显示值 (g)</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-true-weight">0.0</div>
            <div class="metric-label">真实重量 (g)</div>
        </div>
        <div class="metric">
            <div class="metric-value" id="metric-error">0.0</div>
            <div class="metric-label">误差 (g) <span id="stability-indicator" class="stability-indicator unstable"></span></div>
        </div>
    </div>
    
    <div class="info-panel" id="algorithmInfo">
        <strong>组合滤波器 (推荐)</strong>: 先中值滤波去除脉冲，再自适应DC补偿去漂移，最后移动平均得到稳定值。适用于电子秤等需要稳定读数的场景。
    </div>

    <script>
        // --- 1. 基础设置 ---
        const canvas = document.getElementById('scopeCanvas');
        const ctx = canvas.getContext('2d');
        const algorithmInfo = document.getElementById('algorithmInfo');
        
        // 适应屏幕分辨率
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 参数控制
        const params = {
            driftAmp: 80,
            driftSpeed: 0.002,
            noiseAmp: 5,
            intensity: 0.995,
            algorithm: 'combined',
            trueWeight: 0  // 真实重量，由用户设置
        };

        // UI 绑定
        document.getElementById('driftAmp').oninput = function() { 
            params.driftAmp = parseInt(this.value); 
            document.getElementById('val-drift').innerText = this.value;
        };
        document.getElementById('driftSpeed').oninput = function() { 
            let val = parseInt(this.value);
            params.driftSpeed = val * 0.0002; 
            document.getElementById('val-speed').innerText = val;
        };
        document.getElementById('noiseAmp').oninput = function() { 
            params.noiseAmp = parseInt(this.value); 
            document.getElementById('val-noise').innerText = this.value;
        };
        document.getElementById('filterIntensity').oninput = function() { 
            let val = parseInt(this.value);
            params.intensity = val / 1000; 
            document.getElementById('val-intensity').innerText = params.intensity.toFixed(3);
        };
        document.getElementById('filterAlgorithm').oninput = function() { 
            params.algorithm = this.value;
            document.getElementById('val-algo').innerText = this.options[this.selectedIndex].text;
            updateAlgorithmInfo();
            resetFilters();
        };
        
        // 重量控制
        document.getElementById('applyWeight').onclick = function() {
            const weight = parseFloat(document.getElementById('weightInput').value);
            if (!isNaN(weight) && weight >= 0 && weight <= 500) {
                params.trueWeight = weight;
                document.getElementById('val-weight').innerText = weight;
                document.getElementById('metric-true-weight').innerText = weight.toFixed(1);
            }
        };
        
        // 快速重量按钮
        document.getElementById('weight0').onclick = function() {
            params.trueWeight = 0;
            document.getElementById('weightInput').value = 0;
            document.getElementById('val-weight').innerText = '0';
            document.getElementById('metric-true-weight').innerText = '0.0';
        };
        
        document.getElementById('weight50').onclick = function() {
            params.trueWeight = 50;
            document.getElementById('weightInput').value = 50;
            document.getElementById('val-weight').innerText = '50';
            document.getElementById('metric-true-weight').innerText = '50.0';
        };
        
        document.getElementById('weight100').onclick = function() {
            params.trueWeight = 100;
            document.getElementById('weightInput').value = 100;
            document.getElementById('val-weight').innerText = '100';
            document.getElementById('metric-true-weight').innerText = '100.0';
        };
        
        document.getElementById('weight200').onclick = function() {
            params.trueWeight = 200;
            document.getElementById('weightInput').value = 200;
            document.getElementById('val-weight').innerText = '200';
            document.getElementById('metric-true-weight').innerText = '200.0';
        };
        
        // 输入框直接输入重量
        document.getElementById('weightInput').onchange = function() {
            const weight = parseFloat(this.value);
            if (!isNaN(weight) && weight >= 0 && weight <= 500) {
                params.trueWeight = weight;
                document.getElementById('val-weight').innerText = weight;
                document.getElementById('metric-true-weight').innerText = weight.toFixed(1);
            }
        };

        // 更新算法信息面板
        function updateAlgorithmInfo() {
            const infoMap = {
                'dcblocker': '<strong>DC补偿器 (DC Blocker)</strong>: 使用高通滤波器去除低频漂移，输出 = 原始 - 基线。适用于漂移明显的场景。',
                'medianavg': '<strong>移动中值+平均组合</strong>: 中值滤波去除脉冲噪声，移动平均平滑信号。对脉冲噪声效果好。',
                'kalman': '<strong>卡尔曼滤波器</strong>: 最优估计器，自适应调整增益。需要调整Q和R参数。',
                'wavelet': '<strong>小波去噪</strong>: 多尺度分析分离信号与噪声。计算复杂度较高。',
                'adaptive': '<strong>自适应DC补偿</strong>: 动态调整时间常数，区分信号突变和基线漂移。响应速度快。',
                'combined': '<strong>组合滤波器 (推荐)</strong>: 先中值滤波去除脉冲，再自适应DC补偿去漂移，最后移动平均得到稳定值。适用于电子秤等需要稳定读数的场景。'
            };
            algorithmInfo.innerHTML = infoMap[params.algorithm];
        }

        // --- 2. 信号生成工具 ---
        const perm = [];
        let gradP = [];
        
        function seedNoise() {
            gradP = [];
            for(let i=0; i<256; i++) {
                gradP.push(Math.random() * 2 - 1);
            }
        }
        seedNoise();

        function getSmoothNoise(t) {
            const index = Math.floor(t) % 256;
            const nextIndex = (index + 1) % 256;
            const factor = t - Math.floor(t);
            const smoothFactor = (1 - Math.cos(factor * Math.PI)) / 2;
            return gradP[index] * (1 - smoothFactor) + gradP[nextIndex] * smoothFactor;
        }

        // --- 3. 滤波器实现 ---
        
        // 1) DC Blocker 滤波器
        let dcPrevX = 0;
        let dcPrevY = 0;
        
        function dcBlocker(input, alpha) {
            let output = input - dcPrevX + alpha * dcPrevY;
            dcPrevX = input;
            dcPrevY = output;
            return output;
        }
        
        // 2) 移动中值+移动平均组合滤波器
        const medianWindow = 5;
        const avgWindow = 10;
        let medianBuffer = new Array(medianWindow).fill(0);
        let avgBuffer = new Array(avgWindow).fill(0);
        let medianIdx = 0;
        let avgIdx = 0;
        
        function medianAvgFilter(input) {
            // 中值滤波
            medianBuffer[medianIdx] = input;
            medianIdx = (medianIdx + 1) % medianWindow;
            
            const sorted = [...medianBuffer].sort((a,b) => a-b);
            const median = sorted[Math.floor(medianWindow/2)];
            
            // 移动平均
            avgBuffer[avgIdx] = median;
            avgIdx = (avgIdx + 1) % avgWindow;
            
            const sum = avgBuffer.reduce((a,b) => a+b);
            return {
                filtered: sum / avgWindow,
                predicted: sum / avgWindow
            };
        }
        
        // 3) 卡尔曼滤波器
        class KalmanFilter {
            constructor(Q = 0.01, R = 1) {
                this.Q = Q; // 过程噪声
                this.R = R; // 测量噪声
                this.P = 1; // 估计误差协方差
                this.X = 0; // 估计值
            }
            
            update(measurement) {
                // 预测
                const X_pred = this.X;
                const P_pred = this.P + this.Q;
                
                // 更新
                const K = P_pred / (P_pred + this.R); // 卡尔曼增益
                this.X = X_pred + K * (measurement - X_pred);
                this.P = (1 - K) * P_pred;
                
                return {
                    filtered: this.X,
                    predicted: this.X
                };
            }
            
            reset() {
                this.P = 1;
                this.X = 0;
            }
        }
        const kalmanFilter = new KalmanFilter();
        
        // 4) 小波去噪滤波器
        const waveletWindow = 32;
        let waveletBuffer = new Array(waveletWindow).fill(0);
        let waveletIdx = 0;
        
        function waveletDenoise(input) {
            waveletBuffer[waveletIdx] = input;
            waveletIdx = (waveletIdx + 1) % waveletWindow;
            
            // 计算移动平均作为基线
            const baseline = waveletBuffer.reduce((a,b) => a+b) / waveletWindow;
            
            // 对细节系数进行阈值处理
            const detail = input - baseline;
            const threshold = params.noiseAmp * 0.7;
            
            let filteredDetail;
            if(Math.abs(detail) > threshold) {
                // 软阈值
                filteredDetail = Math.sign(detail) * (Math.abs(detail) - threshold);
            } else {
                filteredDetail = 0;
            }
            
            return {
                filtered: baseline + filteredDetail,
                predicted: baseline
            };
        }
        
        // 5) 自适应DC补偿滤波器
        class AdaptiveDCBlocker {
            constructor(slowAlpha = 0.995, fastAlpha = 0.9) {
                this.slowAlpha = slowAlpha;
                this.fastAlpha = fastAlpha;
                this.dcSlow = 0;
                this.dcFast = 0;
            }
            
            process(input) {
                // 快速通道：跟踪信号突变
                this.dcFast = this.fastAlpha * this.dcFast + (1 - this.fastAlpha) * input;
                
                // 慢速通道：跟踪基线漂移
                this.dcSlow = this.slowAlpha * this.dcSlow + (1 - this.slowAlpha) * input;
                
                // 检测信号突变
                const diff = Math.abs(this.dcFast - this.dcSlow);
                const threshold = params.noiseAmp * 3;
                const isSignalChange = diff > threshold;
                
                // 选择跟踪源
                const dcEstimate = isSignalChange ? this.dcSlow : (this.dcFast + this.dcSlow) / 2;
                
                const filtered = input - dcEstimate;
                
                return {
                    filtered: filtered,
                    predicted: dcEstimate,
                    baseline: dcEstimate
                };
            }
            
            reset() {
                this.dcSlow = 0;
                this.dcFast = 0;
            }
        }
        const adaptiveFilter = new AdaptiveDCBlocker(0.995, 0.9);
        
        // 6) 组合滤波器 (中值 + 自适应DC + 移动平均) - 专为电子秤设计
        let combinedMedianBuffer = new Array(5).fill(0);
        let combinedMedianIdx = 0;
        const combinedAdaptiveFilter = new AdaptiveDCBlocker(0.995, 0.95);
        let combinedAvgBuffer = new Array(20).fill(0);
        let combinedAvgIdx = 0;
        
        function combinedFilter(input) {
            // 第一步：中值滤波去除脉冲
            combinedMedianBuffer[combinedMedianIdx] = input;
            combinedMedianIdx = (combinedMedianIdx + 1) % 5;
            const sorted = [...combinedMedianBuffer].sort((a,b) => a-b);
            const median = sorted[Math.floor(5/2)];
            
            // 第二步：自适应DC补偿去漂移
            const adaptiveResult = combinedAdaptiveFilter.process(median);
            const dcRemoved = adaptiveResult.filtered;
            
            // 第三步：移动平均平滑
            combinedAvgBuffer[combinedAvgIdx] = dcRemoved;
            combinedAvgIdx = (combinedAvgIdx + 1) % 20;
            const sum = combinedAvgBuffer.reduce((a,b) => a+b);
            const finalValue = sum / 20;
            
            return {
                filtered: dcRemoved,
                predicted: finalValue,
                baseline: adaptiveResult.baseline
            };
        }
        
        // 7) 稳定性检测器 - 用于确定何时显示稳定值
        class StabilityDetector {
            constructor() {
                this.stableValue = 0;
                this.stableCount = 0;
                this.lastValues = [];
                this.maxBufferSize = 30;
            }
            
            update(currentValue, predictedValue) {
                // 保存最近的值
                this.lastValues.push(currentValue);
                if (this.lastValues.length > this.maxBufferSize) {
                    this.lastValues.shift();
                }
                
                // 计算最近值的方差
                if (this.lastValues.length >= 10) {
                    const mean = this.lastValues.reduce((a, b) => a + b) / this.lastValues.length;
                    const variance = this.lastValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.lastValues.length;
                    
                    // 如果方差足够小，认为数据稳定
                    if (variance < 0.5) {
                        this.stableCount++;
                        if (this.stableCount > 5) {
                            this.stableValue = mean;
                        }
                    } else {
                        this.stableCount = 0;
                        // 如果不稳定，使用预测值
                        this.stableValue = predictedValue;
                    }
                } else {
                    // 数据不足时使用预测值
                    this.stableValue = predictedValue;
                }
                
                return {
                    displayValue: this.stableValue,
                    isStable: this.stableCount > 5
                };
            }
            
            reset() {
                this.stableValue = 0;
                this.stableCount = 0;
                this.lastValues = [];
            }
        }
        
        const stabilityDetector = new StabilityDetector();

        // 重置所有滤波器状态
        function resetFilters() {
            dcPrevX = 0;
            dcPrevY = 0;
            medianBuffer.fill(0);
            avgBuffer.fill(0);
            waveletBuffer.fill(0);
            kalmanFilter.reset();
            adaptiveFilter.reset();
            stabilityDetector.reset();
            combinedMedianBuffer.fill(0);
            combinedAvgBuffer.fill(0);
            combinedAdaptiveFilter.reset();
        }

        // --- 4. 性能指标计算 ---
        function updateMetrics(displayValue, trueWeight) {
            // 1. 当前显示值
            document.getElementById('metric-current').innerText = displayValue.toFixed(1);
            
            // 2. 误差计算
            const error = Math.abs(displayValue - trueWeight);
            document.getElementById('metric-error').innerText = error.toFixed(1);
            
            // 3. 更新稳定性指示灯
            const indicator = document.getElementById('stability-indicator');
            indicator.className = 'stability-indicator ' + (error < 0.5 ? 'stable' : 'unstable');
        }

        // --- 5. 主循环与绘图 ---
        
        // 数据缓冲区
        const maxPoints = 800;
        const dataRaw = new Array(maxPoints).fill(0);
        const dataFiltered = new Array(maxPoints).fill(0);
        const dataDisplay = new Array(maxPoints).fill(0);
        
        let time = 0;

        function loop() {
            // 1. 生成模拟数据
            time += 1;
            
            // A. 真实漂移（电子秤的漂移特性）
            let trueDrift = getSmoothNoise(time * params.driftSpeed) * params.driftAmp;
            
            // B. 高频噪声
            let hfNoise = (Math.random() - 0.5) * params.noiseAmp * 2;

            // 合成原始数据 = 真实重量 + 漂移 + 噪声
            // 注意：rawSample会在真实重量附近波动，因为有漂移和噪声
            let rawSample = params.trueWeight + trueDrift + hfNoise;

            // 2. 根据选择的算法进行滤波处理
            let filteredSample = 0;
            let predictedValue = 0;
            
            switch(params.algorithm) {
                case 'dcblocker':
                    filteredSample = dcBlocker(rawSample, params.intensity);
                    predictedValue = filteredSample;
                    break;
                    
                case 'medianavg':
                    const maResult = medianAvgFilter(rawSample);
                    filteredSample = maResult.filtered;
                    predictedValue = maResult.predicted;
                    break;
                    
                case 'kalman':
                    const kfResult = kalmanFilter.update(rawSample);
                    filteredSample = kfResult.filtered;
                    predictedValue = kfResult.predicted;
                    break;
                    
                case 'wavelet':
                    const waveletResult = waveletDenoise(rawSample);
                    filteredSample = waveletResult.filtered;
                    predictedValue = waveletResult.predicted;
                    break;
                    
                case 'adaptive':
                    const adaptiveResult = adaptiveFilter.process(rawSample);
                    filteredSample = adaptiveResult.filtered;
                    predictedValue = adaptiveResult.predicted;
                    break;
                    
                case 'combined':
                default:
                    const combinedResult = combinedFilter(rawSample);
                    filteredSample = combinedResult.filtered;
                    predictedValue = combinedResult.predicted;
            }
            
            // 3. 使用稳定性检测器得到显示值
            const stabilityResult = stabilityDetector.update(filteredSample, predictedValue);
            const displayValue = stabilityResult.displayValue;

            // 4. 更新性能指标
            updateMetrics(displayValue, params.trueWeight);

            // 5. 更新缓冲区
            dataRaw.shift(); dataRaw.push(rawSample);
            dataFiltered.shift(); dataFiltered.push(filteredSample);
            dataDisplay.shift(); dataDisplay.push(displayValue);

            // 6. 绘图
            draw();

            requestAnimationFrame(loop);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerY = canvas.height / 2;
            const scaleX = canvas.width / maxPoints;
            
            // 计算数据范围用于自动缩放
            // 包含真实重量，以便更好地显示
            const displayData = [...dataRaw, ...dataFiltered, ...dataDisplay, params.trueWeight];
            const maxVal = Math.max(...displayData);
            const minVal = Math.min(...displayData);
            const dataRange = Math.max(Math.abs(maxVal), Math.abs(minVal)) * 1.5;
            const scaleY = canvas.height / (dataRange * 2);

            // 绘制网格
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let y = 0; y <= canvas.height; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            for(let x = 0; x <= canvas.width; x += 100) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();
            
            // 绘制零线和真实重量参考线
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // 绘制真实重量参考线（虚线）
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            const trueWeightY = centerY - params.trueWeight * scaleY;
            ctx.moveTo(0, trueWeightY);
            ctx.lineTo(canvas.width, trueWeightY);
            ctx.stroke();
            ctx.setLineDash([]);

            // 绘制稳定显示值 (黄色，粗线)
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataDisplay[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 绘制原始数据 (红色) - ADC原始数据，包含漂移和噪声
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataRaw[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 绘制滤波后数据 (绿色)
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < maxPoints; i++) {
                let x = i * scaleX;
                let y = centerY - dataFiltered[i] * scaleY;
                if (i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制算法名称和状态
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = 'bold 16px Arial';
            const algoName = document.getElementById('filterAlgorithm').options[document.getElementById('filterAlgorithm').selectedIndex].text;
            ctx.fillText(`算法: ${algoName}`, 10, 25);
            
            // 绘制当前显示值和真实重量
            ctx.font = '14px Arial';
            ctx.fillText(`显示值: ${document.getElementById('metric-current').innerText}g`, 10, 50);
            ctx.fillText(`真实重量: ${params.trueWeight}g`, 10, 70);
            
            // 绘制误差
            const error = parseFloat(document.getElementById('metric-error').innerText);
            ctx.fillStyle = error < 0.5 ? '#00ff00' : '#ff4444';
            ctx.fillText(`误差: ${error.toFixed(2)}g`, 10, 90);
        }

        // 初始化算法信息
        updateAlgorithmInfo();
        
        // 初始化真实重量显示
        document.getElementById('metric-true-weight').innerText = params.trueWeight.toFixed(1);
        
        // 启动
        loop();

    </script>
</body>
</html>